theory ssh

begin

builtins: diffie-hellman, hashing, symmetric-encryption, signing, natural-numbers,xor

functions: pk/1
functions: kdf/1
functions: mac/2
functions: h/1
functions:senc/2
functions:sdec/2
functions:add/2
functions:sign/2
//functions:Z/0
//functions:XOR/2
//functions:zero/0


//equations:x XOR zero = x
//equations:x XOR x = zero

//////KEY_EXCHANGE///////////

//Different algorithm choices for the encryption, the MAC, and the hash function that are negotiated during the key exchanges.

//Rule for proposing algorithms and functions needed for SSH protocol
rule Client_Algorithm_proposals:
    let
        encryption_algos=<'AES', 'ChaCha20'>            //choose some encryption alogorithms by client
        mac_algos=<'HMAC-SHA256','HMAC-SHA1'>           //choose some mac alogorithms by client
        hash_functions=<'SHA-256','SHA-1'>              //choose some hash functions by client
        kex_algorithms=<'diffie-hellman-group1-sha1','diffie-hellman-group14-sha1'>         //choose some key exchange algorithms by client
        server_host_key_algorithms = <'ssh-rsa','rsa-sha2-256'>                             //choose some server host key algorithms by client
        Client_Capabilities=<'SSH_MSG_KEXINIT',~C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos,mac_algos,hash_functions,'0'>                           //Combine all the chosen values with key exchange init message and constant zero value in a tuple
    in
        [Fr(~C_Cookie)                          //Generate a fresh cookie value by client
        ]
        --[SendClientAlgorithmProposal(~C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos,mac_algos,hash_functions),
            Client_send(Client_Capabilities)
        ]->
        [
        Out(Client_Capabilities),                   //send all algorithms list to the server
        Stored_Values_Client1(~C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos,mac_algos,hash_functions)            //Storing all the proposed algorithm values in a linear fact
        ]


//Rule for select algorithm and function by server that can be used further for SSH protocol
rule Server_Algorithm_Selection:
    let
        Selected_encryption='AES'                   //Select an encryption alogorithm by server
        Selected_mac='HMAC-SHA256'                   //Select a mac alogorithm by server
        Selected_hash='SHA-256'                        //Select a hash function by server
        Selected_kex_algo='diffie-hellman-group1-sha1'          //Select a key exchange alogorithm by server
        Selected_server_host_key_algo='ssh-rsa'                 //Select a server host key alogorithm by server
        Client_Capabilities=<'SSH_MSG_KEXINIT',C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos,mac_algos,hash_functions,'0'>
        Server_Selected_Algo=<~S_Cookie,Selected_kex_algo,Selected_server_host_key_algo,Selected_encryption,Selected_mac,Selected_hash>                 //Add all the selected values with the cookie in a tuple
    in
        [
        Fr(~S_Cookie),                                      //Generate a fresh cookie value by server
        In(Client_Capabilities)                             //Receive the client proposed algorithms sent by client
        ]
        --[ ServerAlgorithmSelection(~S_Cookie,Selected_kex_algo,Selected_server_host_key_algo,Selected_encryption,Selected_mac,Selected_hash),
        Server_Send(Server_Selected_Algo)
        ]->
        [
            Out(Server_Selected_Algo),                      //send the selected algorithm and functions to client
            Stored_Values_Server1(C_Cookie,~S_Cookie,Selected_kex_algo,Selected_server_host_key_algo,Selected_encryption,Selected_mac,Selected_hash)         //Storing all the proposed algorithm values in a linear fact
        ]

// Rules for generate server host keys which use for sign exchange hash server value
rule generate_server_host_keys:
        let
        KS_pub = pk(~KS_priv)                   //Generate public key from the private key
        in
        [
            Fr(~KS_priv)                        //Freshly generate a private host key by server
        ]

      --[
        Server_Key(KS_pub)                      

      ]->
        [
            !Store_server_host_keys(~KS_priv,KS_pub)         //Store private and public host keys as persistent fact
            
        ]

// Rules for generate client host keys which use for sign exchange client server value
rule generate_client_host_keys:
    let
        KC_pub = pk(~KC_priv)                       //Generate public key from the private key       
        in
        [
            Fr(~KC_priv)                                        //Freshly generate a private host key by client                 
        ]
        --[
            Client_Key(KC_pub)
    
          ]->
        [
            !Store_client_host_keys(~KC_priv,KC_pub)                    //Store private and public host keys as persistent fact
        ]

// /*Key exchange*/

//Rule for diffie helman key exchange by client

rule key_exchange_client_1:
    let 
        gc='g'^~x                           //calculate diffie helman public key
        Selected_encryption='AES'
        Selected_mac='HMAC-SHA256'
        Selected_hash='SHA-256'
        Selected_kex_algo='diffie-hellman-group1-sha1'
        Selected_server_host_key_algo='ssh-rsa'
        Server_Selected_Algo=<~S_Cookie,Selected_kex_algo,Selected_server_host_key_algo,Selected_encryption,Selected_mac,Selected_hash>
        
    in
    [Fr(~x),                                        //Freshly generate diffie-helman secret key x
    In(Server_Selected_Algo),                       // Receiving server selected algorithm
    Stored_Values_Client1(C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos, mac_algos, hash_functions)
    ]
    --[Client_Send_DH_Pub($C_ID, gc),
        Store_secretkey_Client($C_ID,~x) 
    ]->
    [!DH_Secret_Key($C_ID,~x),                                      //Store Client identifier and diffie-helman secret key x as persistent fact
   // Stored_Values_Client2(C_Cookie,Server_Selected_Algo),
    Stored_Values_Client2(C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos, mac_algos, hash_functions, Server_Selected_Algo, gc),        //Store client cookie value and server selected algorithms and hash functions as linear fact
    Out(<gc,Server_Selected_Algo>)]    //Send diffie helman public key along with the server selected algorithm to confirm the server that client used the algorithms for key exchange

//Rule for diffie helman key exchange by server  after receiving the public key of client and calculate shared secret key
rule key_exchange_server:
    let 
        gs='g'^~y                               //calculate diffie helman public key of server
        k=gc^~y                                 //Calculate shared secret key at server side
        Server_Selected_Algo=<S_Cookie,Selected_kex_algo,Selected_server_host_key_algo,Selected_encryption,Selected_mac,Selected_hash>
        exchange_Hash_server=h(<k,C_Cookie,Server_Selected_Algo,gc,gs,KS_pub>)                  //calculate exchange hash server which is a unique identifier for the connection
        s=sign(exchange_Hash_server,KS_priv)                                                    //sign exchange hash server using the private host key of server
    in
    [
        Fr(~y),                                                 //Freshly generate diffie-helman secret key y at server side
        In(<gc,Server_Selected_Algo>),                          //Receive diffie-helman public key and server selected algorithms sent by client
        Stored_Values_Server1(C_Cookie,S_Cookie,Selected_kex_algo,Selected_server_host_key_algo,Selected_encryption,Selected_mac,Selected_hash),
        !Store_server_host_keys(KS_priv,KS_pub)
    ]
    --[CalculateAndSendExchangeHash(exchange_Hash_server,s),
        Store_secretkey_Server($S_ID,~y),
        Server_Send_DH_Pub($S_ID, gs),
        ComputeSharedSecret($S_ID,k)]->
    [
    Out(<gs,s,KS_pub>),                             //Send diffie helman public key of server, signed value of exchange hash and host key
    !Shared_secret(k),                              //Store shared secret key, k , as persistent fact 
    !DH_Secret_Key($S_ID,~y),                           //Store Server identifier and diffie-helman secret key y as persistent fact 
    Store_as_session_identifier_server(exchange_Hash_server),                               //Store exchange hash server value as linear fact
    Stored_Values_Server2(KS_priv,KS_pub,C_Cookie,S_Cookie,Selected_kex_algo,Selected_server_host_key_algo,Selected_encryption,Selected_mac,Selected_hash, gc, gs)

    ]

//Rule for diffie helman key exchange by client after receiving the public key of server and calculate shared secret key
rule key_exchange_client_2:
    let 
        gc='g'^x                                                              //calculate diffie helman public key
        k=gs^x                                                              //Calculate shared secret key at client side
        exchange_Hash_client=h(<k,C_Cookie,Server_Selected_Algo,gc,gs,KS_pub>)          //calculate exchange hash client which is a unique identifier for the connection
    in
    [
        In(<gs,s,KS_pub>),                                      //Receives diffie helman public key of server, signed value of exchange hash and host key
        !DH_Secret_Key($C_ID,x),                        //retrieve the persistent fact have Server identifier and diffie-helman secret key y
        Stored_Values_Client2(C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos, mac_algos, hash_functions, Server_Selected_Algo, gc)
    ]
    --[Calculate_Exchange_Hash(s),
      ComputeSharedSecret($C_ID,k)]->
    [
        Store_as_session_identifier_client(exchange_Hash_client),                                   //Store exchange hash client value as linear fact
        Stored_Values_Client3(C_Cookie,kex_algorithms,server_host_key_algorithms,encryption_algos, mac_algos, hash_functions, Server_Selected_Algo, gc, gs,s,KS_pub),
        !Shared_secret(k)                                                               //Store shared secret key, k , as persistent fact
    ]



// ///Encryption and Integrity key derivation -use for data encryption and integrity
rule encryption_integrity_key_client:
    let
        EKc=h(<k,exchange_Hash_client,'C'>)             //Calculate encryption key by hashing shared secret key , exchange hash client and constant C    
        IKc=h(<k,exchange_Hash_client,'E'>)             //Calculate integrity key by hashing shared secret key , exchange hash client and constant E   
    in
    [
        !Shared_secret(k),
        Store_as_session_identifier_client(exchange_Hash_client) 
    ]
-->
[
    !St_Encrypted_key(EKc),                             //Store encryption key by client as persistant fact
    !St_Integrity_Key(IKc)                              //Store integrity key by client as persistant fact
]


//Encryption and Integrity key derivation of server side -use for data encryption and integrity
rule encryption_integrity_key_server:
    let
    EKs=h(<k,exchange_Hash_server,'D'>)             //Calculate encryption key by hashing shared secret key , exchange hash client and constant D    
    IKs=h(<k,exchange_Hash_server,'F'>)             //Calculate integrity key by hashing shared secret key , exchange hash client and constant F  
    in
    [
        !Shared_secret(k),
        Store_as_session_identifier_server(exchange_Hash_server)
    ]
-->
[
    !St_Encrypted_key(EKs),                     //Store encryption key by server as persistant fact
    !St_Integrity_Key(IKs)                       //Store integrity key by server as persistant fact
]



// // // /*Client sending server request to Server */
rule service_request_client:
    let
    service_name='SSH - service name'   //client's requested service -could be ssh-userauth or ssh-connection based on context
in
[ 

]
--[RequestService(service_name)]->
[
Out(service_name)                       //Send service request by client
]

// // // /*Server rejecting server request received from client */
rule service_reject_server:
    let
    service_name='SSH - service name'           //client's requested service
    service_reject_msg = 'SSH_MSG_DISCONNECT'    // Message for rejecting the service
in
[
    In(service_name)                        //server receives service request from client
]
--[RejectRequest(service_name)]->
[
    Out(service_reject_msg)                 //sends disconnect message to client
]

// // // /*Server accepting server request received from client */
rule service_accept_server:
    let
    service_name='SSH - service name'
    service_accept_msg = 'SSH_MSG_SERVICE_ACCEPT'           // Message for accepting the service

in
[
    In(service_name)                                //receiving service request from client
]   
--[AcceptRequest(service_name)]->
[
    Out(<service_accept_msg,'SSH_MSG_NEWKEYS'>)                     //send accept message to client 
]


 /*Client send data after server accepting the service request */
rule client_send_data:
    let
    service_accept_msg = 'SSH_MSG_SERVICE_ACCEPT'
    sequence_number = %1                                   //Initialized to one by assuming this as first packet - Reason to initialize to 1 is mentioned in documentation
    mac_data = mac(IKc,<sequence_number,'unencrypted_data'>)    //Client send data by maintaining the encrption and integrity- mac value is calculate using integrity key
    encrypted_data=senc('unencrypted_data',EKc)                 //Data is Encrypted using encryption key
    //added_value=add(sequence_number,1:nat)
    added_value=(sequence_number %+ %1)                             //sequence number is incremented by 1 for every data packet

in
[
    In(<service_accept_msg,'SSH_MSG_NEWKEYS'>),             //Receives the service accept message to start data transmitting
    !St_Encrypted_key(EKc),
    !St_Integrity_Key(IKc)
]
--[SendData(mac_data)



]->
[
   Out(<encrypted_data,mac_data>),                              //Send the encrypted and mac data for preserving confidentiality and integrity
   !Increment_Store_sequence_number_client(added_value)      //for next packets this incremented sequence number needs to be used
]

// // /*Server accepts data from client */
rule server_accept_data:
    let
    EKc=h(<k,exchange_Hash_server,'C'>)
    IKc=h(<k,exchange_Hash_server,'E'>)
    encrypted_data=senc('unencrypted_data',EKc)
    unencrypted_data=sdec(encrypted_data,EKc)                       //encrypted data is decrypted using the encryption key and read the data
    sequence_number=%1
    mac_data = mac(IKc,<sequence_number,unencrypted_data>)
    verified_mac=mac(IKs,<sequence_number,unencrypted_data>)                //Mac data is verified using the integrity key and verify the integrity
    added_value=(sequence_number %+ %1)
in
[
    In(<encrypted_data,mac_data>),                  //receives the encrypted and mac data in a tuple sent by client
    Store_as_session_identifier_server(exchange_Hash_server),       //Retrieve session identifier ,exchange hash server
    !St_Encrypted_key(EKs),                                         //Retrieve Encrypted key of server
    !St_Integrity_Key(IKs),                                         //Retrieve Integrity key of server
    !Shared_secret(k)                                               //Retrieve Shared secret key of server
]
--[DecryptData(encrypted_data,mac_data)]->
[Increment_Store_sequence_number_server(added_value)      //for next packets this incremented sequence number needs to be used
]

// // // ////KEY-REEXCHANGE- After transmitting data for some time
//Rule for server to send key reexchange initialisation message
rule key_reexchange_server_1:
    let
    EKc=h(<k,exchange_Hash_server,'C'>)
    encrypted_data=senc('unencrypted_data',EKc)
    init_msg='SSH_MSG_KEXINIT'                          //message for initiate key reexchange
    in
    [
        In(encrypted_data),                                         //Receiving encrypted data from client for some time
        Store_as_session_identifier_server(exchange_Hash_server),
        !Shared_secret(k)

    ]
    --[
        Initiate_KeyReExchange(init_msg)
    ]->
    [Out(init_msg)]                                         //Send the init message to inform client to start key re exchange

//Rule for client to receive key reexchange init message from server and start the key reexchange with new diffie-helman client public key
rule key_reexchange_client_1:
    let 
        gc_new='g'^~x                           //diffie-helman client public key
        init_msg='SSH_MSG_KEXINIT'
        
    in
    [   
        In(init_msg),
        Fr(~x)                              //freshly generate diffie-helman secret key of client
    ]
    --[ComputeNewKeys(gc_new)]->
    [!Client_Secret_Key(~x),            //Store diffie-helman secret key as persistant fact
        Out(gc_new)]                    //send newly created diffie-helman client public key

//Rule for key re exchange for server to generate new diffie-helman server public key and calculate new shared secret key
rule key_reexchange_server_2:
    let 
        gs_new='g'^~y                   //calculate diffie-helman server public key
        k=gc_new^~y                     //calculate shared secret key
    in
    [
        Fr(~y),                                 //generate diffie-helman secret key
        In(gc_new)                               //Receive newly created diffie-helman client public key
    ]
    --[]->
    [
    Out(gs_new),                                 //send newly created diffie-helman server public key
    !Shared_secret_new(k)                   //Store shared secret key as persistant fact
    ]

//Rule for key re exchange for client to calculate new shared secret key by client
rule key_reexchange_client_2:
    let 
        gc_new=g^x      //client public key
        k=gs_new^x
    in
    [
        In(gs_new),!Client_Secret_Key(x)
    ]
    -->
    [
        !Shared_secret_new(k)
    ]


//Rule for new key calculation of encryption and integrity keys by client in Key reexchange phase
rule encryption_integrity_key_client_reexchange:
    let
        EKc=h(<k,exchange_Hash_client,'C'>)             //Calculate encryption key by client
        IKc=h(<k,exchange_Hash_client,'E'>)             //Calculate integrity key by client
    in
    [
    !Shared_secret_new(k),  
    Store_as_session_identifier_client(exchange_Hash_client)
    
    ]
-->
[
    !St_Encrypted_key_new(EKc),                               //Store new encryption key by client as persistant fact
    !St_Integrity_Key_new(IKc)                                  //Store new integrity key by client as persistant fact
]


rule encryption_integrity_key_server_reexchange:
    let
    EKs=h(<k,exchange_Hash_server,'D'>)
    IKs=h(<k,exchange_Hash_server,'F'>)
    in
    [
    !Shared_secret_new(k),
    Store_as_session_identifier_server(exchange_Hash_server)
    
    ]
-->
[
    !St_Encrypted_key_new(EKs),
    !St_Integrity_Key_new(IKs)
]

//Rule for send service request during key re exchange
rule service_request_reexchange_client:
    let
    service_name='SSH - service name'   //could be ssh-userauth or ssh-connection based on context
in
[ 

]
--[RequestService(service_name)]->
[
Out(service_name)
]

// // // /*Accepting service request messages during re-key exchanges. */
rule service_accept_reexchange_server:
    let
    service_name='SSH - service name'
    service_accept_msg = 'SSH_MSG_SERVICE_ACCEPT'           // Message sent by the server to accept the service

in
[
    In(service_name)
]
--[
   // AcceptRequest(service_name)
]->
[
    Out(<service_accept_msg,'SSH_MSG_NEWKEYS'>)
]


// // /* Additional adversarial capabilities like, for instance, key reveals */

rule reveal_dh_key:
    [
        !DH_Secret_Key($ID,a)                                         //Retrieve persitant fact for ID and diffie helman secret key    
    ]
    --[Reveal_dh_key($ID)]->
    [
        Out(a)                                                         //Send diffie helman secret key 
    ]


rule Reveal_shared_secretKey:
[
    !Shared_secret(k)
]
--[Reveal_shared_secret(k)]->
[
    Out(k)
]

rule reveal_encryption_key:
    [
        !St_Encrypted_key(Ek)                                               
    ]
    --[Reveal_encrypted_key(Ek)]->
    [
        Out(Ek)                                                         
    ]

rule reveal_integrity_key:
    [
        !St_Encrypted_key(Ik)                                               
    ]
    --[Reveal_encrypted_key(Ik)]->
    [
        Out(Ik)                                                         
    ]


lemma capabilities_check:
exists-trace
"Ex #i #j Client_Capabilities Server_Selected_Algo .
Client_send(Client_Capabilities) @i &
Server_Send(Server_Selected_Algo) @j
"

lemma Keys_check:
exists-trace
"
Ex #i #j KS_pub KC_pub.
Server_Key(KS_pub) @i &
Client_Key(KC_pub) @j
"

lemma Keys_Exchange_check:
exists-trace
"
Ex #i #j #k gs gc C S s  .
Client_Send_DH_Pub(C, gc) @i &
Server_Send_DH_Pub(S, gs) @j &
Calculate_Exchange_Hash(s) @k
"


lemma secrecy:
" All C_ID S_ID x y k #i #j .
Store_secretkey_Client(C_ID,x) @#i
 & ComputeSharedSecret(C_ID,k) @#i
 & Store_secretkey_Server(S_ID,y) @#j
 & ComputeSharedSecret(S_ID,k) @#j
 ==> ( not (Ex #n. K(x) @n) 
 & not(Ex #n. K(y) @n)
 & not (Ex #n. K(k) @n))
 "

lemma algorithmSelection:
exists-trace
"
Ex #i Server_Selected_Algo #j Client_Capabilities.
Server_Send(Server_Selected_Algo)@i & 
Client_send(Client_Capabilities) @j 

"

lemma dataSendAgreement:
"All mac_data #i.
SendData(mac_data) @#i
==> (Ex service_name #j.
    AcceptRequest(service_name) @#j & j<i)"


lemma keyReExchangeAgreement:
"All gc_new #i.
ComputeNewKeys(gc_new) @#i
==> (Ex SSH_MSG_KEXINIT #j.
    Initiate_KeyReExchange(SSH_MSG_KEXINIT) @#j & j<i)
"

end